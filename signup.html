<!DOCTYPE html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>STI ProWare Sign Up</title>
  <link rel="icon" type="png" href="Logo2.png">
  <link rel="stylesheet" href="design.css">
</head>
<body>
<div class="signup">
  <div class="signup-container">
    <h2>STI ProWare Sign Up</h2>
       <br>
    <form action="#">
      <div class="form-group">
        <label for="name">Full Name</label>
        <input type="text" id="name" placeholder="Last Name, First Name, Middle Name" required>
      </div>
      
      <div class="form-group">
        <label for="email">Email</label>
        <input type="email" id="email" placeholder="Enter your student email" required>
      </div>
      
      <div class="form-group">
        <label for="StudentID">Student ID</label>
        <input type="text" id="StudentID" placeholder="02000******" name="student_id" pattern="[0-9]{11}" required>
      </div>
      
      <div class="form-group">
        <label for="password">Password</label>
        <input type="password" id="password" placeholder="Enter your password" pattern="(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,}" required>
      </div>
      
      <div class="form-group">
        <label for="password">Confirm Password</label>
        <input type="password" id="Confirmpassword" placeholder="Enter your password again..." pattern="(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,}" required>
      </div>

      <div class="form-group-terms">
        <label for="terms">
          <input type="checkbox" id="terms" name="terms" required>
        <a href="#" onclick="openModal()"> Terms and Conditions</a>
        </label>
      </div>
      
      <div id="termsModal" class="modal">
        <div class="modal-content">
          <span class="close" onclick="closeModal()">&times;</span>
          <h2>Terms and Conditions</h2>
          <p>
            Welcome to ProWare! It is an online platform for ordering merchandise for schools. By using this platform, you agree to the following terms and conditions. Please read them carefully prior to placing any order.<br>
           <br>
            For user legibility:<br>
            <br>
            •	ProWare is only made available to students or staff members currently enrolled at STI College Novaliches.<br>
            •	Alumni have the privilege of browsing the goods but cannot place any order directly. They may ask for help from the currently enrolled students.<br>
            •	Unauthorized access to the system is strictly prohibited and will be appropriately penalized.<br>
            <br>
            Ordering Process:<br>
            <br>
            •	Orders need to be placed on the official ProWare platform.<br>
            •	The users shall be responsible to ensure that each order is complete with details including the quantity and the product chosen before submission.<br>
            •	Once an order is submitted, it cannot be modified or canceled unless approved by the system administrator.<br>
            <br>
            Payment:<br>
            <br>
            •	Orders will only be processed once payment is received and confirmed.<br>
            <br>
            PickUp and Order Tracking:<br>
            <br>
            •	Users will be notified of their order status via the ProWare tracking system.<br>
            •	Pickup location and times will be provided upon order confirmation.<br>
            •	Users must ensure to pick up their orders within the specified pickup period. <br>
            Otherwise, it will be rescheduled for another pick up date.<br>
            <br>
             Security and Account Access:<br>
             <br>
            •	MFA is used by ProWare to protect users' accounts. <br>
            •	Users must keep any access credentials private and must not share account details with anyone. <br>
            •	Unusual activity should be reported to the system administrator without delay.<br>
            •	ProWare is not liable for any losses caused by the user’s failure to maintain account security.<br>    
          </p>
        </div>
        </div>

        <a href="index.html"><button type="submit" class="submit-btn">Sign Up</button></a>
    </form>
   
    <div class="login-link">
      Already have an account? <a href="#">Login here</a>
    </div>
    </div>
</div> 

  <script>
    function openModal() {
      document.getElementById("termsModal").style.display = "block";
    }
    
    function closeModal() {
      document.getElementById("termsModal").style.display = "none";
    }
    </script>
</body>
</html>
<!--# @loginbp.route('/signup', methods=['POST', 'GET'])
# def signup():
#     if 'user' in session:
#         return redirect(url_for('home'))

#     ip = request.remote_addr
#     now = datetime.utcnow()

#     # Block IP if too many failed attempts
#     if ip in failed_signup_attempts:
#         attempt_info = failed_signup_attempts[ip]
#         if attempt_info['count'] >= MAX_ATTEMPTS:
#             if now - attempt_info['last_attempt'] < BLOCK_TIME:
#                 block_time_left = BLOCK_TIME - (now - attempt_info['last_attempt'])
#                 block_minutes = block_time_left.seconds // 60
#                 block_seconds = block_time_left.seconds % 60
#                 flash(f'Too many failed attempts. Your IP is blocked for {block_minutes} minutes and {block_seconds} seconds. Please try again later.')
#                 return render_template('signup.html')
#             else:
#                 # Reset block after BLOCK_TIME
#                 failed_signup_attempts.pop(ip)

#     if request.method == 'POST':
#         fullname = request.form['full_name']
#         email = request.form['email']
#         std_id = request.form['student_id']
#         password = request.form['password']
#         confirmpassword = request.form['confirm_password']
        
#         find_acc = db_account.find_one({'email': email, 'std_id': std_id})
        
#         allowed_domain = r'^[a-zA-Z0-9._%+-]+@novaliches\.sti\.edu\.ph$'
#         if not re.match(allowed_domain, email):
#             flash('Please use your @novaliches.sti.edu.ph student email.')
#             return render_template('signup.html')
        
#         if find_acc:
#             flash('Email already exists. Please use a different email or student ID.')
#             return render_template("signup.html")
        
#         if password != confirmpassword:
#             flash("Passwords do not match")
#             return render_template("signup.html")
        
#         otp = ''.join([str(random.randint(0, 9)) for _ in range(6)])   
#         session['pending_user'] = {
#             'fullname': fullname,
#             'email': email,
#             'password': bcrypt.generate_password_hash(password).decode('utf-8'),
#             'std_id': std_id,
#             'role': 'user',
#             'otp': otp,
#             'otp_created_at': datetime.utcnow().isoformat(),
#             'otp_attempts': 0
#         }

#         send_otp_email(email, otp)
#         print("Signup OTP sent")
#         return redirect(url_for('login.otp_verification'))  # Redirect to OTP verification page

#     return render_template('signup.html')

# @loginbp.route('/otp_verify', methods=['GET', 'POST'])
# def otp_verification():
#     if 'user' in session:
#         return redirect(url_for('home'))

#     signup_pending = session.get('pending_user')
#     if not signup_pending:
#         flash('Session expired. Please sign up again.')
#         return redirect(url_for('login.signup'))

#     ip = request.remote_addr
#     now = datetime.utcnow()

#     # Block IP if too many failed attempts
#     if ip in failed_signup_attempts:
#         attempt_info = failed_signup_attempts[ip]
#         if attempt_info['count'] >= MAX_ATTEMPTS:
#             if now - attempt_info['last_attempt'] < BLOCK_TIME:
#                 flash('Too many failed attempts from your IP. Try again later.')
#                 return render_template('otp_verify.html')  # Render the page instead of redirecting
#             else:
#                 # Reset block after BLOCK_TIME
#                 failed_signup_attempts.pop(ip)

#     if request.method == 'POST':
#         user_otp = request.form['otp_verification']
#         otp_time = datetime.fromisoformat(signup_pending['otp_created_at'])

#         if datetime.utcnow() - otp_time > timedelta(minutes=5):
#             session.pop('pending_user')
#             flash('OTP expired. Please sign up again.')
#             return render_template('otp_verify.html')  # Render the page instead of redirecting

#         if signup_pending['otp_attempts'] >= 5:
#             session.pop('pending_user')
#             flash('Too many attempts. Please sign up again.')
#             return render_template('otp_verify.html')  # Render the page instead of redirecting

#         if user_otp == signup_pending['otp']:
#             # Save user to the database
#             db_account.insert_one({
#                 'fullname': signup_pending['fullname'],
#                 'email': signup_pending['email'],
#                 'std_id': signup_pending['std_id'],
#                 'password': signup_pending['password'],
#                 'role': signup_pending['role']
#             })

#             session.pop('pending_user')

#             # Reset IP failure count on success
#             failed_signup_attempts.pop(ip, None)

#             flash('Signup successful! Please login to continue.')
#             return redirect(url_for('login.login_'))
#         else:
#             signup_pending['otp_attempts'] += 1
#             session['pending_user'] = signup_pending
#             flash('Invalid OTP. Try again.')

#             # Track IP failed attempts
#             failed_signup_attempts.setdefault(ip, {'count': 0, 'last_attempt': now})
#             failed_signup_attempts[ip]['count'] += 1
#             failed_signup_attempts[ip]['last_attempt'] = now

#     return render_template('otp_verify.html')
-->